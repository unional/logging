{"version":3,"file":"color-map.js","sources":["../../../../../../color-map/createColors.ts","../../../../../../color-map/createColorsFromMap.ts","../../../../../../color-map/rgbHex.ts","../../../../../../color-map/rgbaString.ts","../../../../../../color-map/index.ts"],"sourcesContent":["import { RGB, RGBA, Alpha } from './interfaces'\n\nexport function createColors(from: RGB, to: RGB, shades: number, alpha?: Alpha): RGBA[] {\n  const rgba: any[] = []\n  const start = [...from]\n  const diff = [\n    to[0] - from[0],\n    to[1] - from[1],\n    to[2] - from[2]\n  ]\n  if (alpha) {\n    start.push(alpha[0])\n    diff.push(alpha[1] - alpha[0])\n  }\n  for (let i = 0; i < shades; i++) {\n    const inc = 1 /\n      Math.max(shades - 1, 1)\n    const color = [\n      Math.round(start[0] + i * diff[0] * inc),\n      Math.round(start[1] + i * diff[1] * inc),\n      Math.round(start[2] + i * diff[2] * inc),\n      alpha ? start[3] + i * diff[3] * inc : 1\n    ]\n    rgba.push(color)\n  }\n  return rgba\n}\n","import { ColorMap, Alpha, RGBA, RGB } from './interfaces'\nimport { createColors } from './createColors'\n\n/**\n * Create colors with specified color map.\n */\nexport function createColorsFromMap(colormap: ColorMap, shades: number, alpha?: Alpha): RGBA[] {\n  if (shades < colormap.length) {\n    throw new Error(`Requires at least ${colormap.length} shades.`)\n  }\n\n  const result: RGBA[] = []\n  const steps: number[] = []\n  for (let i = 0; i < colormap.length; i++) {\n    steps.push(Math.round(colormap[i].index * shades))\n  }\n\n  for (let i = 0; i < colormap.length - 1; i++) {\n    const n = steps[i + 1] - steps[i]\n    const from: RGB = colormap[i].rgb;\n    const to = colormap[i + 1].rgb;\n    result.push(...createColors(from, to, n, alpha))\n  }\n\n  return result\n}\n","import { RGB } from './interfaces'\n\n/**\n * Convert `RGB` to `#rgb`\n * JavaScript note: no check for array length, use it properly.\n */\nexport function rgbHex(rgb: RGB) {\n  let hex = '#'\n  for (let i = 0; i < 3; i++) {\n    hex += d2h(rgb[i])\n  }\n  return hex\n}\n\nfunction d2h(d: number) {\n  let s = (+d).toString(16)\n  return s.length < 2 ? '0' + s : s\n}\n","import { RGBA } from './interfaces'\n\nexport function rgbaString(rgba: RGBA) {\n  return 'rgba(' + rgba.join(',') + ')';\n}\n","export * from './createColors'\nexport * from './createColorsFromMap'\nexport * from './interfaces'\nexport * from './rgbHex'\nexport * from './rgbaString'\n"],"names":["from","to","shades","alpha","rgba","start","diff","push","i","inc","Math","max","color","round","colormap","length","Error","result","steps","index","n","rgb","createColors_1","hex","d2h","d","s","toString","join","__export"],"mappings":"oGAEA,WAA6BA,EAAWC,EAASC,EAAgBC,GAC/D,GAAMC,MACAC,EAAYL,UACZM,GACJL,EAAG,GAAKD,EAAK,GACbC,EAAG,GAAKD,EAAK,GACbC,EAAG,GAAKD,EAAK,GAEXG,KACFE,EAAME,KAAKJ,EAAM,IACjBG,EAAKC,KAAKJ,EAAM,GAAKA,EAAM,IAE7B,KAAK,GAAIK,GAAI,EAAGA,EAAIN,EAAQM,IAAK,CAC/B,GAAMC,GAAM,EACVC,KAAKC,IAAIT,EAAS,EAAG,GACjBU,GACJF,KAAKG,MAAMR,EAAM,GAAKG,EAAIF,EAAK,GAAKG,GACpCC,KAAKG,MAAMR,EAAM,GAAKG,EAAIF,EAAK,GAAKG,GACpCC,KAAKG,MAAMR,EAAM,GAAKG,EAAIF,EAAK,GAAKG,GACpCN,EAAQE,EAAM,GAAKG,EAAIF,EAAK,GAAKG,EAAM,EAEzCL,GAAKG,KAAKK,GAEZ,MAAOR,GCnBT,WAAoCU,EAAoBZ,EAAgBC,GACtE,GAAID,EAASY,EAASC,OACpB,KAAM,IAAIC,OAAM,qBAAqBF,EAASC,kBAKhD,KAAK,GAFCE,MACAC,KACGV,EAAI,EAAGA,EAAIM,EAASC,OAAQP,IACnCU,EAAMX,KAAKG,KAAKG,MAAMC,EAASN,GAAGW,MAAQjB,GAG5C,KAAK,GAAIM,GAAI,EAAGA,EAAIM,EAASC,OAAS,EAAGP,IAAK,CAC5C,GAAMY,GAAIF,EAAMV,EAAI,GAAKU,EAAMV,GACzBR,EAAYc,EAASN,GAAGa,IACxBpB,EAAKa,EAASN,EAAI,GAAGa,GAC3BJ,GAAOV,WAAPU,EAAeK,eAAatB,EAAMC,EAAImB,EAAGjB,IAG3C,MAAOc,GClBT,WAAuBI,GAErB,IAAK,GADDE,GAAM,IACDf,EAAI,EAAGA,EAAI,EAAGA,IACrBe,GAAOC,EAAIH,EAAIb,GAEjB,OAAOe,GAGT,WAAaE,GACX,GAAIC,KAAMD,GAAGE,SAAS,GACtB,OAAOD,GAAEX,OAAS,EAAI,IAAMW,EAAIA,ECdlC,WAA2BtB,GACzB,MAAO,QAAUA,EAAKwB,KAAK,KAAO,IHDpC,mLIFAC,KACAA,KAEAA,KACAA"}